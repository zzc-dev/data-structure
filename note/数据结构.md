# 一、稀疏数组

# 二、链表

## 2.1 单向链表

单链表的常见面试题有如下:

1)求单链表中有效节点的个数

2)查找单链表中的倒数第k个结点 【新浪面试题】

3)单链表的反转【腾讯面试题，有点难度】

4)从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】

5)合并两个有序的单链表，合并之后的链表依然有序

## 2.2 双向链表

管理单向链表的缺点分析: 

1)单向链表，**查找的方向只能是一个方向**，而双向链表可以向前或者向后查找。

2)单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以**自我删除**，单链表删除
   时节点，总是找到temp,temp是待删除节点的前一个节点.

## 2.3 约瑟夫问题

> Josephu 问题为：
>
> 设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

**提示**：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束



# 三、队列

队列是一个有序列表，可以用**数组**或是**链表**来实现。

遵循**先入先出**的原则。即：先存入队列的数据，要先取出。后存入的要后取出

# 四、栈

## 4.1 介绍

栈是一个**先入后出**(FILO-First In Last Out)的有序列表。

栈(stack)是限制线性表中元素的插入和删除**只能在线性表的同一端**进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为**栈顶**(Top)，另一端为固定的一端，称为**栈底**(Bottom)。

## 4.2 实现综合计算器

### 4.2.1 中缀表达式

**7\*2\*2-5+1-5+3-4**

算法：

```
1. 定义一个数栈numStack和一个符号栈operStack, 通过索引（下标index）遍历表达式
2. 如果发现是一个数字,直接入numStack
3. 如果发现是一个符号：
   3.1 此时operStack为空 直接入栈
   3.2 如果operStack不为空，将当前操作符与栈顶元素比较：
      ① 当前操作符的优先级 > operStack栈顶元素,直接入栈
      ② 否则，从numStack中pop出两个数进行运算（后出 运算符 先出）后将结果入numStack，并将当前操作符入operStack
4. 当表达式扫描完毕，顺序从数栈和符号栈中pop出响应的数和符号并计算
5. 最后数栈中只有一个数字，就是表达式的结果
```

### 4.2.2 前缀表达式

算法：

```
从右至左扫描表达式，
   遇到数字时，将数字压入堆栈，
   遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；
重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果
```

例如: (3+4)×5-6 对应的前缀表达式就是 **- × + 3 4 5** **6 ,** **针对前缀表达式求值步骤**如下

1)从**右至左扫描**，将6、5、4、3压入堆栈

2)遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈

3)接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈

4)最后是-运算符，计算出35-6的值，即29，由此得出最终结果

### 4.2.3 后缀表达式 *

> 后缀表达式又称**逆波兰表达式**

 (3+4)×5-6 对应的后缀表达式就是 **3** **4 + 5 × 6** **–**

**算法：**

```
从左至右扫描表达式，
   遇到数字时，将数字压入堆栈，
   遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；
   重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果
```

例如: (3+4)×5-6 对应的后缀表达式就是 **3 4 + 5 × 6 -** **,** 针对后缀表达式求值步骤如下:

1)从左至右扫描，将3和4压入堆栈；

2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；

3)将5入栈；

4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；

5)将6入栈；

最后是-运算符，计算出35-6的值，即29，由此得出最终结果

### 4.2.4 中缀转后缀

**算法**

```
1)初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2)从左至右扫描中缀表达式；
3)遇到操作数时，将其压s2；
4)遇到运算符时，比较其与s1栈顶运算符的优先级：
  (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
  (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1；
  (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；
5)遇到括号时：
  (1) 如果是左括号“(”，则直接压入s1
  (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6)重复步骤2至5，直到表达式的最右边
7)将s1中剩余的运算符依次弹出并压入s2
8)依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
```

举例：

中缀表达式“1+((2+3)×4)-5”  --> 后缀表达式"1 2 3 + 4 × + 5 –"

| 扫描到的元素 | s2(栈底->栈顶)         | s1 (栈底->栈顶) | 说明                               |
| ------------ | ---------------------- | --------------- | ---------------------------------- |
| 1            | 1                      | 空              | 数字，直接入栈                     |
| +            | 1                      | +               | s1为空，运算符直接入栈             |
| (            | 1                      | + (             | 左括号，直接入栈                   |
| (            | 1                      | + ( (           | 同上                               |
| 2            | 1 2                    | + ( (           | 数字                               |
| +            | 1 2                    | + ( ( +         | s1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3                  | + ( ( +         | 数字                               |
| )            | 1 2 3 +                | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +                | + ( ×           | s1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4              | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×            | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +          | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5        | -               | 数字                               |
| 到达最右端   | **1  2 3 + 4 × + 5 -** | 空              | s1中剩余的运算符                   |





## 4. 栈的应用场景

1.  子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。  
2.  处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3.  表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4.  二叉树的遍历。
5.  图形的深度优先(depth一first)搜索法。

