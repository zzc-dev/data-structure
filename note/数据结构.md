# 一、稀疏数组

# 二、链表

## 2.1 单向链表

单链表的常见面试题有如下:

1)求单链表中有效节点的个数

2)查找单链表中的倒数第k个结点 【新浪面试题】

3)单链表的反转【腾讯面试题，有点难度】

4)从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】

5)合并两个有序的单链表，合并之后的链表依然有序

## 2.2 双向链表

管理单向链表的缺点分析: 

1)单向链表，**查找的方向只能是一个方向**，而双向链表可以向前或者向后查找。

2)单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以**自我删除**，单链表删除
   时节点，总是找到temp,temp是待删除节点的前一个节点.

## 2.3 约瑟夫问题

> Josephu 问题为：
>
> 设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

**提示**：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束



# 三、队列

队列是一个有序列表，可以用**数组**或是**链表**来实现。

遵循**先入先出**的原则。即：先存入队列的数据，要先取出。后存入的要后取出

# 四、栈

## 4.1 介绍

栈是一个**先入后出**(FILO-First In Last Out)的有序列表。

栈(stack)是限制线性表中元素的插入和删除**只能在线性表的同一端**进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为**栈顶**(Top)，另一端为固定的一端，称为**栈底**(Bottom)。

## 4.2 实现综合计算器

### 4.2.1 中缀表达式

**7\*2\*2-5+1-5+3-4**

算法：

```
1. 定义一个数栈numStack和一个符号栈operStack, 通过索引（下标index）遍历表达式
2. 如果发现是一个数字,直接入numStack
3. 如果发现是一个符号：
   3.1 此时operStack为空 直接入栈
   3.2 如果operStack不为空，将当前操作符与栈顶元素比较：
      ① 当前操作符的优先级 > operStack栈顶元素,直接入栈
      ② 否则，从numStack中pop出两个数进行运算（后出 运算符 先出）后将结果入numStack，并将当前操作符入operStack
4. 当表达式扫描完毕，顺序从数栈和符号栈中pop出响应的数和符号并计算
5. 最后数栈中只有一个数字，就是表达式的结果
```

### 4.2.2 前缀表达式

算法：

```
从右至左扫描表达式，
   遇到数字时，将数字压入堆栈，
   遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；
重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果
```

例如: (3+4)×5-6 对应的前缀表达式就是 **- × + 3 4 5** **6 ,** **针对前缀表达式求值步骤**如下

1)从**右至左扫描**，将6、5、4、3压入堆栈

2)遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈

3)接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈

4)最后是-运算符，计算出35-6的值，即29，由此得出最终结果

### 4.2.3 后缀表达式 *

> 后缀表达式又称**逆波兰表达式**

 (3+4)×5-6 对应的后缀表达式就是 **3** **4 + 5 × 6** **–**

**算法：**

```
从左至右扫描表达式，
   遇到数字时，将数字压入堆栈，
   遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；
   重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果
```

例如: (3+4)×5-6 对应的后缀表达式就是 **3 4 + 5 × 6 -** **,** 针对后缀表达式求值步骤如下:

1)从左至右扫描，将3和4压入堆栈；

2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；

3)将5入栈；

4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；

5)将6入栈；

最后是-运算符，计算出35-6的值，即29，由此得出最终结果

### 4.2.4 中缀转后缀

**算法**

```
1)初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2)从左至右扫描中缀表达式；
3)遇到操作数时，将其压s2；
4)遇到运算符时，比较其与s1栈顶运算符的优先级：
  (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
  (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1；
  (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；
5)遇到括号时：
  (1) 如果是左括号“(”，则直接压入s1
  (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6)重复步骤2至5，直到表达式的最右边
7)将s1中剩余的运算符依次弹出并压入s2
8)依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
```

举例：

中缀表达式“1+((2+3)×4)-5”  --> 后缀表达式"1 2 3 + 4 × + 5 –"

| 扫描到的元素 | s2(栈底->栈顶)         | s1 (栈底->栈顶) | 说明                               |
| ------------ | ---------------------- | --------------- | ---------------------------------- |
| 1            | 1                      | 空              | 数字，直接入栈                     |
| +            | 1                      | +               | s1为空，运算符直接入栈             |
| (            | 1                      | + (             | 左括号，直接入栈                   |
| (            | 1                      | + ( (           | 同上                               |
| 2            | 1 2                    | + ( (           | 数字                               |
| +            | 1 2                    | + ( ( +         | s1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3                  | + ( ( +         | 数字                               |
| )            | 1 2 3 +                | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +                | + ( ×           | s1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4              | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×            | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +          | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5        | -               | 数字                               |
| 到达最右端   | **1  2 3 + 4 × + 5 -** | 空              | s1中剩余的运算符                   |





## 4. 栈的应用场景

1.  子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。  
2.  处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3.  表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4.  二叉树的遍历。
5.  图形的深度优先(depth一first)搜索法。

# 五、递归

## 1.迷宫问题

## 2. 八皇后问题（回溯算法）

算法步骤：

```
1.第一个皇后先放第一行第一列
2.第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
3.继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 
```

# 六、排序

1) 内部排序:

指将需要处理的所有数据都加载到内部存储器中进行排序。

2) 外部排序法：

数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

## 6.1 时间复杂度

**时间频度**

> **一个算法中的语句执行次数称为语句频度或时间频度**。记为T(n)



•用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6  => T(n)=n²+7n+1

•修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n²

•去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

**常见的时间复杂度**

1)常数阶O(1)

2)对数阶O(log2n)

3)线性阶O(n)

4)线性对数阶O(nlog2n)

5)平方阶O(n^2)

6)立方阶O(n^3)

7)k次方阶O(n^k)

8)指数阶O(2^n)

常见的算法时间复杂度由小到大依次为：**Ο(1)＜Οlog2n)＜Ο(n)＜Ο(nlog2n)＜ Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜Ο(2^n)** ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

**平均时间复杂度和最坏时间复杂度**

1)平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

2)最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。

平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)

![image-20201128193157464](D:\myself\data-structure\note\image\sort01.png)

## 6.2  空间复杂度

1)类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。

2)空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况

3)在做算法分析时，**主要讨论的是时间复杂度**。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.

## 6.3 冒泡排序

> 冒泡排序（Bubble Sorting）的基本思想是：
>
> ​	通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

## 6.4 选择排序

>选择排序（select sorting）基本思想：
>
>​	第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列

## 6.5 插入排序

>插入排序（Insertion Sorting）的**基本思想**：
>
>​	把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

## 6.6 希尔排序

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种**插入排序**，它是简单插入排序经过改进之后的一个**更高效的版本**，也称为缩小增量排序。

>**希尔排序法基本思想**:
>
>​	希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

![image-20201128193854667](D:\myself\data-structure\note\image\sort02.png)

## 6.7 快速排序

> 快速排序（Quicksort）是对冒泡排序的一种改进。
>
> 基本思想是：
> 	通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

**实现**

填数+分治法

```
1. 选择数组中的任意位置的一个元素pivot作为基准，
2. 将小于基准元素的移到左边，大于基准元素的移到右边
3. 数组被pivot分成两部分，接着对左右两部分做1、2操作
4. 直到所有子集被处理完毕
```



![image-20201128194215150](D:\myself\data-structure\note\image\sort03.png)

**性能**

快排的性能在所有排序算法里面是最好的，数据规模越大快速排序的性能越优。快排在极端情况下会退化成 ![[公式]](https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29) 的算法，因此**假如在提前得知处理数据可能会出现极端情况的前提下**，可以选择使用较为稳定的归并排序

## 6.8 归并排序

> 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)

![image-20201128194357513](D:\myself\data-structure\note\image\sort04.png)

## 6.9 基数排序

1)基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法

2)基数排序(Radix Sort)是**[桶排序](http://www.cnblogs.com/skywang12345/p/3602737.html)**的扩展

> 基本思想:
>
> ​	将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列

**注意**：

1)基数排序是对传统桶排序的扩展，速度很快.

2)基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。

3)基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，**则称这种排序算法是稳定的；否则称为不稳定的**]

4)有负数的数组，我们不用基数排序来进行排序,如果要支持负数，参考[https://](https://code.i-harness.com/zh-CN/q/e98fa9)[code.i-harness.com/zh-CN/q/e98fa9](https://code.i-harness.com/zh-CN/q/e98fa9)

## 6.10 堆排序

[二叉树章节](#8.5 堆排序)

## 6.11 总结

![image-20201129115649270](D:\myself\data-structure\note\image\sort05.png)

# 七、查找算法

## 7.1 线性查找

## 7.2 二分查找

![image-20201129120300478](D:\myself\data-structure\note\image\find01.png)

## 7.3 插值查找

类似于二分查找，就是找中值的方法不一样

![image-20201129120318404](D:\myself\data-structure\note\image\find02.png)



**性能**

1)对于数据量较大，**关键字分布比较均匀**的查找表来说，采用**插值查找速度较快**

2)关键字分布不均匀的情况下，该方法不一定比折半查找要好

## 7.4 斐波那契（黄金分割法）查找

![image-20201129120506171](D:\myself\data-structure\note\image\find03.png)

> F(k) = F(k-1) + F(k-2)    => F(k) - 1 = F(k-1)-1 + F(k-2) - 1 + 1
>
> `mid=left + F(k-1)-1`

斐波那契查找关键在找数组长度的黄金分割点，因此当数组长度不满足斐波那契数列的值时，需要数组补长
最好给补长的值是原数组的最后一个元素

注意：

 第一次找到k的位置后，再向左查找：k=k-1 左边的长度是F(k-1) - 1
                                             向右查找：k=k-2 右边的长度是F(k-2) - 1

这里的F(k)都是长度，因此在下一次迭代时在找黄金分割点时需要正确的长度

# 八、二叉树

1)数组存储方式的分析
 优点：通过下标方式访问元素，速度快。**对于有序数组**，还可使用二分查找提高检索速度。
 缺点：如果要检索具体某个值，或者插入值(按一定顺序)**会整体移动**，效率较低 [示意图]

2)链式存储方式的分析
 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。
 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】

3)树**存储方式的分析
 能提高数据**存储，读取**的效率, 比如利用 **二叉排序树**(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度

## 8.1 分类

**满二叉树**

该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数

**完全二叉树**

该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续

## 8.2 遍历

### 8.2.1 前序遍历

> 1.先输出当前节点  
> 2.再输出左节点
> 3.最后输出右节点

**非递归方法实现**

```
1. 先定义一个栈用于存放变量栈，把根节点放入栈中
2. 抛出栈顶元素，输出，把该节点的右节点和左节点一次放入栈中（先右后左）
3. 重复2直到栈空
```

### 8.2.2 中序遍历

> 1.先输出左节点 
> 2.再输出当前节点 
> 3.最后输出右节点

**非递归方法实现**

```
1. 初始化栈，令curNode = root
2. 先将curNode压入栈中，然后令curNode=curNode.left,一次压入栈中，直到curNode为空
3. 弹出栈顶元素并打印，在使curNode=栈顶元素.right，一直重复2，直到栈空为止
```

### 8.2.3 后续遍历

> 1.先输出左节点 
> 2.再输出右节点
> 3.最后输出当前节点 

**非递归方法实现**

```
1. 定义两个栈s1,s2,首先将root压入s1
2. 从s1弹出一个元素，压入s2,并将s1的左右节点依次压入s1
3. 重复2,直到s1为空
```

## 8.3 顺序存储二叉树

从数据存储来看，**数组存储方式**和**树**的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，

**特点**

1)顺序二叉树通常只考虑完全二叉树

2)第n个元素的左子节点为 2 * n + 1 

3)第n个元素的右子节点为 2 * n + 2

4)第n个元素的父节点为 (n-1) / 2

5)n : 表示二叉树中的第几个元素

## 8.4 线索化二叉树

> n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。
>
> 利用二叉链表中的空指针域，存放指向**该**[结](https://baike.baidu.com/item/结点)[点](https://baike.baidu.com/item/结点)在**某种遍历次序**下的前驱和后继结点的指针（这种附加的指针称为"线索"）
>
> 1)一个结点的前一个结点，称为**前驱**结点
> 2)一个结点的后一个结点，称为**后继**结点

## 8.5 堆排序

>1)堆排序是利用**堆**这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
>
>2)堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 
>   注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。
>
>3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

>基本思想：
>
>1)将待排序序列构造成一个大顶堆
>
>2)此时，整个序列的最大值就是堆顶的根节点。
>
>3)将其与末尾元素进行交换，此时末尾就为最大值。
>
>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

## 8.6 赫夫曼树

### 8.6.1 基本概念

1） 给定n个权值作为n叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为**最优二叉树**，也称为**哈夫曼树(Huffman Tree**),

2）赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近

3）路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。
          通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1

4）**结点的权及带权路径长度**：**若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。**
          结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积

4)**树的带权路径长度**：**树的带权路径长度规定为所有**叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

5)**WPL****最小的就是赫夫曼树**

### 8.6.2 构建赫夫曼树

构成赫夫曼树的步骤：

1)从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树

2)取出根节点权值最小的两颗二叉树

3)组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 

4)再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

### 8.6.3 赫夫曼编码

1)赫夫曼编码广泛地用于数据文件压缩。其**压缩率通常在20%～90%**之间

2)赫夫曼码是可变[字长](https://baike.baidu.com/item/字长/97660)编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

**文件压缩和解压**























